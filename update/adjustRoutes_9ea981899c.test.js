// ********RoostGPT********
// Test generated by RoostGPT for test JavaTesting using AI Type Open AI and AI Model gpt-4-1106-preview



// ********RoostGPT********
const { adjustRoutes } = require('./update-aliases');
const { diff, toExpression, toActions, addRoute, deleteRoute } = jest.requireActual('./route-helpers');

jest.mock('./route-helpers', () => ({
  diff: jest.fn(),
  toExpression: jest.fn(),
  toActions: jest.fn(),
  addRoute: jest.fn(),
  deleteRoute: jest.fn(),
}));

describe('adjustRoutes', () => {
  const fakeDomain = 'test.com';
  const fakeCreds = { user: 'test', pass: 'test' };
  let routes;
  let aliases;
  let dryRun;
  let callback;

  beforeAll(() => {
    jest.spyOn(console, 'log').mockImplementation(() => {});
  });

  beforeEach(() => {
    routes = { items: [] };
    aliases = [];
    dryRun = false;
    callback = jest.fn();
    toExpression.mockImplementation((domain, alias) => `expr-${alias.from}`);
    toActions.mockImplementation((alias) => `actions-${alias.from}`);
    diff.mockReturnValue([]);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  afterAll(() => {
    console.log.mockRestore();
  });

  test('should add new routes', () => {
    aliases = [{ from: 'alias1', to: 'destination1' }];
    routes.items = [];
    diff.mockReturnValueOnce(aliases).mockReturnValueOnce([]);

    adjustRoutes(routes, fakeDomain, fakeCreds, dryRun, callback);

    expect(addRoute).toHaveBeenCalledWith(fakeDomain, fakeCreds, 'alias1', 'expr-alias1', 'actions-alias1', expect.any(Function));
    expect(deleteRoute).not.toHaveBeenCalled();
    expect(callback).toHaveBeenCalledTimes(1);
  });

  test('should remove obsolete routes', () => {
    routes.items = [{ id: 'route1', expression: 'expr-alias1' }];
    aliases = [];
    diff.mockReturnValueOnce([]).mockReturnValueOnce(routes.items);

    adjustRoutes(routes, fakeDomain, fakeCreds, dryRun, callback);

    expect(deleteRoute).toHaveBeenCalledWith(fakeDomain, fakeCreds, 'route1', expect.any(Function));
    expect(addRoute).not.toHaveBeenCalled();
    expect(callback).toHaveBeenCalledTimes(1);
  });

  test('should handle dry run without making changes', () => {
    dryRun = true;
    aliases = [{ from: 'alias1', to: 'destination1' }];
    routes.items = [{ id: 'route1', expression: 'expr-alias1' }];
    diff.mockReturnValueOnce(aliases).mockReturnValueOnce(routes.items);

    adjustRoutes(routes, fakeDomain, fakeCreds, dryRun, callback);

    expect(addRoute).not.toHaveBeenCalled();
    expect(deleteRoute).not.toHaveBeenCalled();
  });

  test('should log added and removed routes', () => {
    aliases = [{ from: 'alias1', to: 'destination1' }];
    routes.items = [{ id: 'route1', expression: 'expr-alias1' }];
    diff.mockReturnValueOnce(aliases).mockReturnValueOnce(routes.items);

    adjustRoutes(routes, fakeDomain, fakeCreds, dryRun, callback);

    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('route(s) to add'));
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('route(s) to remove'));
  });
});
