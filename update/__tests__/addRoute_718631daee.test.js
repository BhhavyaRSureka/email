// ********RoostGPT********
// Test generated by RoostGPT for test NodeTesting using AI Type Open AI and AI Model gpt-4



// ********RoostGPT********
const hyperquest = require('hyperquest');
const bl = require('bl');
const qs = require('querystring');
const addRoute = require('../add-route');

describe('addRoute', () => {
  let mockPost;
  let mockBl;

  beforeAll(() => {
    mockPost = jest.spyOn(hyperquest, 'post');
    mockBl = jest.spyOn(bl, 'bl');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should successfully add a route', (done) => {
    const mockCallback = jest.fn();
    const mockReq = {
      pipe: jest.fn().mockReturnThis(),
      end: jest.fn(),
    };
    mockPost.mockReturnValue(mockReq);
    mockBl.mockReturnValue(mockCallback);

    addRoute('test.com', { 'api-key': '1234' }, 'test', 'test', 'test', mockCallback);

    expect(mockPost).toHaveBeenCalledWith('test.com', expect.objectContaining({
      auth: 'api:1234',
      headers: expect.objectContaining({
        'content-type': 'application/x-www-form-urlencoded',
      }),
    }));
    expect(mockReq.pipe).toHaveBeenCalledWith(mockCallback);
    expect(mockReq.end).toHaveBeenCalled();
    done();
  });

  it('should handle errors', (done) => {
    const mockCallback = jest.fn();
    const mockReq = {
      pipe: jest.fn().mockReturnThis(),
      end: jest.fn(),
    };
    mockPost.mockReturnValue(mockReq);
    mockBl.mockImplementation(() => {
      throw new Error('Test Error');
    });

    addRoute('test.com', { 'api-key': '1234' }, 'test', 'test', 'test', mockCallback);

    expect(mockPost).toHaveBeenCalled();
    expect(mockReq.pipe).not.toHaveBeenCalled();
    expect(mockReq.end).not.toHaveBeenCalled();
    done();
  });
});
